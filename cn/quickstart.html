<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en" data-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Java Promise快速入门</title>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css?v=2.1.1">

<!-- JS -->
<script type="text/javascript" src="dochack.js?v=2.1.1"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Java Promise快速入门</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">🌗 Match OS</option>
        <option value="dark">🌑 Dark</option>
        <option value="light">🌕 Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple">
        <li><a id="indexLink" href="theindex.html">Index</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput" oninput="search()"/>
    </div>
    <div>
      Group by:
      <select onchange="groupBy(this.value)">
        <option value="section">Section</option>
        <option value="type">Type</option>
      </select>
    </div>
    <ul class="simple simple-toc" id="toc-list">
  <li><a class="reference" id="简介_toc" href="#简介">简介</a></li>
<li><a class="reference" id="deferred_toc" href="#deferred">Deferred</a></li>
<li><a class="reference" id="核心接口_toc" href="#核心接口">核心接口</a></li>
<ul class="simple"><li><a class="reference" id="核心接口-then_toc" href="#核心接口-then">then</a></li>
<li><a class="reference" id="核心接口-except_toc" href="#核心接口-except">except</a></li>
<li><a class="reference" id="核心接口-done_toc" href="#核心接口-done">done</a></li>
<li><a class="reference" id="核心接口-next_toc" href="#核心接口-next">next</a></li>
<li><a class="reference" id="核心接口-timeout_toc" href="#核心接口-timeout">timeout</a></li>
</ul><li><a class="reference" id="实用接口_toc" href="#实用接口">实用接口</a></li>
<ul class="simple"><li><a class="reference" id="实用接口-delay_toc" href="#实用接口-delay">delay</a></li>
<li><a class="reference" id="实用接口-recover_toc" href="#实用接口-recover">recover</a></li>
<li><a class="reference" id="实用接口-retry_toc" href="#实用接口-retry">retry</a></li>
<li><a class="reference" id="实用接口-validation_toc" href="#实用接口-validation">validation</a></li>
</ul><li><a class="reference" id="流程控制_toc" href="#流程控制">流程控制</a></li>
<ul class="simple"><li><a class="reference" id="流程控制-join_toc" href="#流程控制-join">join</a></li>
<li><a class="reference" id="流程控制-abort_toc" href="#流程控制-abort">abort</a></li>
</ul><li><a class="reference" id="并发控制_toc" href="#并发控制">并发控制</a></li>
<ul class="simple"><li><a class="reference" id="并发控制-all_toc" href="#并发控制-all">all</a></li>
<li><a class="reference" id="并发控制-race_toc" href="#并发控制-race">race</a></li>
<li><a class="reference" id="并发控制-any_toc" href="#并发控制-any">any</a></li>
<li><a class="reference" id="并发控制-allsettled_toc" href="#并发控制-allsettled">allSettled</a></li>
</ul><li><a class="reference" id="内存安全_toc" href="#内存安全">内存安全</a></li>
<li><a class="reference" id="其他说明_toc" href="#其他说明">其他说明</a></li>
<ul class="simple"><li><a class="reference" id="其他说明-使用要求_toc" href="#其他说明-使用要求">使用要求</a></li>
<li><a class="reference" id="其他说明-资源_toc" href="#其他说明-资源">资源</a></li>
</ul>
</ul>

  </div>
  <div class="nine columns" id="content">
    
    <div id="tocRoot"></div>
    
    <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Version:</th><td>5.0.6</td></tr>
<tr><th class="docinfo-name">Date:</th><td>2022-9</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="简介" href="#简介">简介</a></h1><p>异步与并发是业务编码过程中的一大难题，为了解决这个问题，在各种语言或库中都提供了异步任务控制机制。Java通过系统库的方式提供了对 Future 的支持。在 1.5 引入了 Future，在 JDK 8 引入了<a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a>，进一步完善了 Future 机制。</p>
<p><pre class="listing">
<span class="Identifier">CompletableFuture</span><span class="Operator">&lt;</span><span class="Identifier">HistoryData</span><span class="Operator">&gt;</span> <span class="Identifier">tag</span> <span class="Operator">=</span> <span class="Identifier">previousTag</span><span class="Punctuation">.</span><span class="Identifier">thenCompose</span><span class="Punctuation">(</span><span class="Keyword">this</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">toNow</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Keyword">return</span> <span class="Identifier">tag</span><span class="Punctuation">.</span><span class="Identifier">thenCompose</span><span class="Punctuation">(</span><span class="Identifier">hd</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Keyword">if</span> <span class="Punctuation">(</span><span class="Identifier">Objects</span><span class="Punctuation">.</span><span class="Identifier">isNull</span><span class="Punctuation">(</span><span class="Identifier">hd</span><span class="Punctuation">)</span> <span class="Operator">||</span> <span class="Identifier">CollectionUtils</span><span class="Punctuation">.</span><span class="Identifier">isEmpty</span><span class="Punctuation">(</span><span class="Identifier">hd</span><span class="Punctuation">.</span><span class="Identifier">getInfos</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
        <span class="Keyword">return</span> <span class="Identifier">getHistoryFromStore</span><span class="Punctuation">(</span><span class="Identifier">hd</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
    <span class="Punctuation">}</span>
    <span class="Keyword">return</span> <span class="Identifier">CompletableFuture</span><span class="Punctuation">.</span><span class="Identifier">completedFuture</span><span class="Punctuation">(</span><span class="Identifier">hd</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>
<p>不过，采用 Future 模式后，引入了一些新的复杂度，并且原有的部分痛点仍然没有解决，尤其是：</p>
<ul class="simple"><li>可能会从命令式编程(Imperative Programming)转换为声明式编程(Declarative Programming)，声明式编程通常并不直观，理解成本较高。</li>
<li>同步语义与异步语义的转换并不简单。Future 的API 有较高的学习成本。比如 CompletableFuture 各种组合的方法非常复杂。</li>
<li>错误处理仍然较复杂。 Future 通常包含 Running/Cancelled/Failed/Done 状态，部分状态又是通过异常来处理的，完整地处理错误仍然很冗长。</li>
<li>Future 并不方便对中间状态进行测试。对于一个链状的 Future，通常不方便指定异步执行顺序，以此发现可能的并发错误。当然，这是所有并发编程的共同困难。</li>
</ul>
<p>为进一步降低异步与并发控制的难度，我们借鉴其他语言的设计，在Java中实现Promise机制，即当执行一个异步任务时，许诺（Promise）在某个时间点会返回执行结果，这个表示未知结果的实体被称为Promise。使用Promise抽象可以大大降低开发者的心智负担，极大提高编码效率，降低出错可能性。</p>
<p>我们先来看一段使用Promise后的代码片段，针对计算密集型任务，实现多线程下计算任务。</p>
<p><pre class="listing">
<span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">Integer</span><span class="Operator">&gt;</span> <span class="Identifier">promise</span> <span class="Operator">=</span> <span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">resolve</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Keyword">int</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">;</span>
<span class="Keyword">do</span> <span class="Punctuation">{</span>
    <span class="Keyword">int</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">i</span><span class="Punctuation">;</span>
    <span class="Identifier">promise</span> <span class="Operator">=</span> <span class="Identifier">promise</span><span class="Punctuation">.</span><span class="Identifier">next</span><span class="Punctuation">(</span><span class="Identifier">n</span> <span class="Operator">-&gt;</span> <span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">resolve</span><span class="Punctuation">(</span><span class="Identifier">n</span> <span class="Operator">+</span> <span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span> <span class="Keyword">while</span> <span class="Punctuation">(</span><span class="Operator">++</span><span class="Identifier">i</span> <span class="Operator">&lt;=</span> <span class="DecNumber">100</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Keyword">int</span> <span class="Identifier">val</span> <span class="Operator">=</span> <span class="Identifier">promise</span><span class="Punctuation">.</span><span class="Identifier">join</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Identifier">assertThat</span><span class="Punctuation">(</span><span class="Identifier">val</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">isEqualTo</span><span class="Punctuation">(</span><span class="DecNumber">5050</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>
<p>我们可以看到，与Javascript等弱类型语言相比，Java是强类型的。（<tt class="docutils literal"><span class="pre"><span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span></span></tt>应读作<tt class="docutils literal"><span class="pre"><span class="Identifier">Promise</span> <span class="Keyword">of</span> <span class="Identifier">String</span></span></tt>）。使用泛型机制可以使代码编写起来更加安全，方便。另外Javascript不支持多线程，我们设计的Promise组件是天然支持多线程的。</p>
<p>上述例子，每一个累加的操作均在不同的线程执行，我们内置了两个简单通用的线程池，在默认情况下，Promise使用<tt class="docutils literal"><span class="pre"><span class="Identifier">ForkJoinPool</span></span></tt>做为线程池，适合计算密集型任务。针对阻塞IO类型，可以使用内置的<tt class="docutils literal"><span class="pre"><span class="Identifier">Promise</span><span class="Operator">.</span><span class="Identifier">ThreadPerTaskExecutor</span></span></tt>这种简单的线程池模型。如果需要更复杂的策略，则可以使用自定义线程池，在构造函数中传入。</p>
<p>针对不同的场景，设计上我们把一个异步任务抽象成两种类型，一种是适合大多数场景，常规的需要立即执行的任务，我们称作<tt class="docutils literal"><span class="pre"><span class="Identifier">Promise</span></span></tt>，另外一种是需要延迟执行的异步任务，我们称作<a class="reference internal" href="#deferred">Deferred</a>。</p>

<h1><a class="toc-backref" id="deferred" href="#deferred">Deferred</a></h1><p><span id="deferred_1">Deferred</span> 是一个不立即执行的Promise，实现<strong>数据消费</strong>与<strong>数据获取</strong>的分离。</p>
<p><pre class="listing">
<span class="Comment">// 生成一个promise对象</span>
<span class="Identifier">Deferred</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span> <span class="Identifier">deferred</span> <span class="Operator">=</span> <span class="Keyword">new</span> <span class="Identifier">Deferred</span><span class="Operator">&lt;&gt;</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Comment">//数据消费</span>
<span class="Identifier">deferred</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// s的值为something，此处对s进行处理</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Comment">//数据获取</span>
<span class="Identifier">deferred</span><span class="Punctuation">.</span><span class="Identifier">offer</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="StringLit">&quot;something&quot;</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Comment">//以上两个步骤并没有先后顺序的要求，执行的结果是一致的</span>
<span class="Comment">//因为promise对象的状态是缓存的，减少很多因时序产生的问题。</span></pre></p>
<p>通常情况下，数据的获取和消费通常是一起编写的，但仔细分析我们发现这其实两个完全不同的事情。</p>
<p>在工厂产线中，如果工人不但要负责加工商品（数据消费），还要负责去取待加工商品(数据获取)，这通常是小作坊的做法。而专业的流水线，每个工人，坐等流水线把商品送到面前，只需简单完成自己负责的工序即可。小作坊的方式加重了工人的心智负担，更容易出错，降低了流水线的效率。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">Deferred</span></span></tt>帮助我们抽象了这个过程，完成了数据获取和数据处理这两个事情的分离，更好的履行了<tt class="docutils literal"><span class="pre"><span class="Identifier">单一职责</span><span class="Punctuation">(</span><span class="Identifier">SRP</span><span class="Punctuation">)</span></span></tt>的思想。</p>
<p>在实践中，比如一个函数接口返回一个String，代表函数调用者可以立即使用这个String，如果要表达<strong>将来</strong>要使用String的语义，就无能为力了。<strong>Deferred</strong>提供了这个语义，它表达的语义是<strong>将来</strong>会提供一个String，至于谁来提供这个String，怎么获取这个String，那完全是另外一回事，不需要数据处理者关心，数据处理者只需要知道如何处理这个数据并送入下一道工序即可。</p>
<p>由于<strong>Deferred</strong>也是一个<strong>Promise</strong>，因此完全具备Promise所具有的能力，Deferred相比Promise只是多了一个<strong>Initialized</strong>状态，如下图</p>
<p><pre class="listing">
                   +-------------------+
                   |                   |
   Deferred-------&gt;|    Initialized    |
                   |                   |
                   +---------+---------+
                             |
+----------------------------+---------------------------+
|                            |                           |
|                  +---------v---------+                 |
|                  |                   |                 |
|   Promise-------&gt;|      Pending      |                 |
|                  |                   |                 |
|                  +---------+---------+                 |
|                            |                           |
|   +----------------+       |        +---------------+  |
|   |                |       |        |               |  |
|   |    Resovled    &lt;-------+--------&gt;    Rejected   |  |
|   |                |                |               |  |
|   +-------+--------+                +--------+------+  |
|           |                                  |         |
|           |        +---------------+         |         |
|           |        |               |         |         |
|           +--------&gt;     Done      &lt;---------+         |
|                    |               |                   |
|                    +---------------+                   |
|                                                        |
+--------------------------------------------------------+</pre></p>

<h1><a class="toc-backref" id="核心接口" href="#核心接口">核心接口</a></h1><p>仅需几分钟，掌握以下核心接口的使用方法，就能令你在日常工作中事半功倍。</p>

<h2><a class="toc-backref" id="核心接口-then" href="#核心接口-then">then</a></h2><p><span id="then_1">then</span> 方法上一步异步操作成功时执行，返回一个新的Promise。</p>
<p><pre class="listing">
<span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
     <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="StringLit">&quot;something&quot;</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// s is something</span>
        <span class="Comment">// TODO 对something进行处理</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>

<h2><a class="toc-backref" id="核心接口-except" href="#核心接口-except">except</a></h2><p><span id="except_1">except</span> 与then相反，在异步操作失败时执行，返回一个新的Promise。</p>
<p><pre class="listing">
<span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
     <span class="Identifier">reject</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// s is something</span>
      <span class="Comment">// TODO 失败时的处理逻辑</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>
<p>使用以上两个接口就可以实现一个简单的异步任务处理流程。在Android下，可以取代 <a class="reference external" href="https://developer.android.com/reference/android/os/AsyncTask">AsyncTask</a>。</p>
<p><pre class="listing">
<span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
      <span class="Comment">//执行异步任务</span>
      <span class="Comment">//如成功，调用resolve改变状态</span>
      <span class="Comment">//如失败，调用reject改变状态</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">//成功时的处理</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
      <span class="Comment">//失败时的处理</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>
<p>当然由于<tt class="docutils literal"><span class="pre"><span class="Identifier">Promise的每个接口返回的都是一个新的Promise</span></span></tt>你也可以这么写</p>
<p><pre class="listing">
<span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">//执行异步任务</span>
      <span class="Comment">//如成功，调用resolve改变状态</span>
      <span class="Comment">//如失败，调用reject改变状态</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
      <span class="Comment">//失败时的处理</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
      <span class="Comment">//成功时的处理</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>
<p>对于执行结果没有任何影响，到这里为止，你已经掌握了Promise的基本用法了。</p>

<h2><a class="toc-backref" id="核心接口-done" href="#核心接口-done">done</a></h2><p><span id="done_1">done</span> 在上一步异步操作状态确定时执行(成功或失败)，返回一个新的Promise。在一些场景下，我们并不关心异步任务是成功，还是失败，比如数据上报之类的，只是需要在任务执行完毕时进行一些操作。</p>
<p><pre class="listing">
<span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">//执行异步任务</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">done</span><span class="Punctuation">(</span><span class="Identifier">o</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">//异步任务完成，不管是成功还是失败</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>
<blockquote class="markdown-quote"><p>注意:promise的状态一旦确定，就不会再改变自身的状态和其数据，这是跟状态机的区别。</p></blockquote>
<p>由于Promise的每一个接口返回的都是一个新的Promise对象，因此允许我们进行链式操作，解决了常规基于回调编程带来的<tt class="docutils literal"><span class="pre"><span class="Identifier">回调地狱</span></span></tt>问题。以上两个代码片段，均会返回一个新的Promise对象，其类型是 <tt class="docutils literal"><span class="pre"><span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">Integer</span><span class="Operator">&gt;</span></span></tt>。 以上接口能够满足单个异步任务的处理流程，实际情况下异步任务往往有串行和并行的需求，Promise拥有强大的异步操作抽象描述能力，使我们可以对异步任务处理流程进行组合。</p>
<p>下面我们看一种常见的情形 <strong>串行组合</strong>，这里我们需要引入一个新的接口<a class="reference internal" href="#核心接口-next">next</a>，更高级的组合方式，请参考 <a class="reference internal" href="#并发控制">并发控制</a></p>

<h2><a class="toc-backref" id="核心接口-next" href="#核心接口-next">next</a></h2><p><span id="next_1">next</span> 操作在上一步异步操作成功时执行，接收上一步的结果，发起下一个新的异步任务，返回该任务的Promise，可以做数据类型的转换。</p>
<p><pre class="listing">
<span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="StringLit">&quot;something&quot;</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">next</span><span class="Punctuation">(</span><span class="Identifier">o</span> <span class="Operator">-&gt;</span> <span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">Integer</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="Identifier">o</span><span class="Punctuation">.</span><span class="Identifier">length</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">integer</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// integer is 9</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>
<p>在实际情况下，由于各种原因异步处理流程可能失败，因此我们最好加入异常处理分支。</p>
<p><pre class="listing">
<span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="StringLit">&quot;something&quot;</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">next</span><span class="Punctuation">(</span><span class="Identifier">o</span> <span class="Operator">-&gt;</span> <span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">Integer</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="Identifier">o</span><span class="Punctuation">.</span><span class="Identifier">length</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">integer</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// integer is 9</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">//失败时的处理流程</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>

<h2><a class="toc-backref" id="核心接口-timeout" href="#核心接口-timeout">timeout</a></h2><p>Promise A+规范里没有定义超时(<span id="timeout_1">timeout</span> )的标准处理方式，但超时处理在实际业务环境下是非常普遍的，因此我们对规范进行扩展，内置了对超时的支持。 以下代码，如异步任务在1秒内没有完成(主动调用resolve或reject)，该Promise自动进入错误状态(即reject状态)。<blockquote class="markdown-quote"><p>延时操作，如定时器，一般是导致应用内存泄露问题的根源，如Promise在定时器结束之前扭转状态(resolve或reject)，则定时器会被自动取消，以免产生内存泄露。</p></blockquote>
</p>
<p><pre class="listing">
<span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
  <span class="Comment">// 须在指定时间内，调用resolve或者reject传递结果，否则自动扭转为reject状态</span>
<span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">Timeout</span><span class="Punctuation">.</span><span class="Identifier">ofSeconds</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">err</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
  <span class="Comment">// 错误处理流程</span>
  <span class="Comment">// 如果1s内没有任务没有完成，则err为 PromiseTimeoutException</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
      <span class="Comment">//成功时的处理</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>
<p>以上就是Promise的核心接口。</p>

<h1><a class="toc-backref" id="实用接口" href="#实用接口">实用接口</a></h1><p>以下接口提供实践中经常需要用到的能力，此类接口均是对Promise核心API的包装。</p>

<h2><a class="toc-backref" id="实用接口-delay" href="#实用接口-delay">delay</a></h2><p>我们可以非常简单的给任意一个Promise对象加入<span id="delay_1">delay</span> 延时执行的效果，可以替代<tt class="docutils literal"><span class="pre"><span class="Identifier">Thread</span><span class="Operator">.</span><span class="Identifier">sleep</span></span></tt>，此接口返回加入延迟效果的新Promise。</p>
<p>具体使用方法举例</p>
<p><pre class="listing">
<span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="StringLit">&quot;something&quot;</span><span class="Punctuation">)</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">delay</span><span class="Punctuation">(</span><span class="Identifier">Timeout</span><span class="Punctuation">.</span><span class="Identifier">ofMillis</span><span class="Punctuation">(</span><span class="DecNumber">500</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">o</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
   <span class="Comment">// 延迟500ms收到结果</span>
   <span class="Comment">// o is something</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span></pre></p>
<p>或者静态方法的形式，本质一样的。</p>
<p><pre class="listing">
<span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">delay</span><span class="Punctuation">(</span><span class="Identifier">aPromise</span><span class="Punctuation">,</span> <span class="Identifier">Timeout</span><span class="Punctuation">.</span><span class="Identifier">ofMillis</span><span class="Punctuation">(</span><span class="Identifier">delay</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre></p>
<p>也可以以延迟操作作为业务逻辑的起点。</p>
<p><pre class="listing">
<span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">delay</span><span class="Punctuation">(</span><span class="Identifier">Timeout</span><span class="Punctuation">.</span><span class="Identifier">ofMillis</span><span class="Punctuation">(</span><span class="DecNumber">500</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">next</span><span class="Punctuation">(</span><span class="Identifier">unused</span> <span class="Operator">-&gt;</span> <span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
   <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="StringLit">&quot;something&quot;</span><span class="Punctuation">)</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">o</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
   <span class="Comment">// 延迟500ms收到结果</span>
   <span class="Comment">// o is something</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>

<h2><a class="toc-backref" id="实用接口-recover" href="#实用接口-recover">recover</a></h2><p>可以非常简单的给任意一个Promise对象加入异常恢复逻辑<span id="recover_1">recover</span> 。在上一步异步操作失败时执行，接收上一步错误信息，执行新的获取<tt class="docutils literal"><span class="pre"><span class="Identifier">同类型数据</span></span></tt>的异步任务，返回该任务的Promise。</p>
<p>常见的应用场景：</p>
<ul class="simple"><li>读取缓存失败，从网络中读取</li>
<li>网络错误，切换IP重试</li>
</ul>
<p>此方法跟<tt class="docutils literal"><span class="pre"><span class="Identifier">next</span></span></tt>接口有相似之处，区别如下</p>
<table border="1" class="docutils"><tr><th>接口</th><th>执行时机</th><th>数据类型</th></tr>
<tr><td><strong>next</strong></td><td>上一步成功时执行</td><td><strong>可以</strong>返回与上一步<strong>不同数据类型</strong>的Promise</td></tr>
<tr><td><strong>recover</strong></td><td>上一步失败时执行</td><td><strong>必须</strong>返回与上一步<strong>相同数据类型</strong>的Promise</td></tr>
</table><p>典型使用方法</p>
<p><pre class="listing">
<span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">reject</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="StringLit">&quot;error&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Punctuation">.</span><span class="Identifier">recover</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="StringLit">&quot;something&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// s is something</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span></pre></p>
<p>或者静态方法的形式</p>
<p><pre class="listing">
<span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span> <span class="Identifier">aPromise</span> <span class="Operator">=</span> <span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">reject</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="StringLit">&quot;error&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Comment">//错误恢复</span>
<span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">recover</span><span class="Punctuation">(</span><span class="Identifier">aPromise</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="StringLit">&quot;something&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
        <span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
              <span class="Comment">// s is something</span>
        <span class="Punctuation">}</span><span class="Punctuation">)</span></pre></p>
<p>因为recover返回的也是一个新的Promise对象，可以实现非常灵活的恢复逻辑，比如多次尝试，或者加入延时等策略，请参考<a class="reference internal" href="#实用接口-retry">retry</a>。</p>

<h2><a class="toc-backref" id="实用接口-retry" href="#实用接口-retry">retry</a></h2><p><span id="retry_1">retry</span> 简单来说就是以一定的策略，来执行recover的过程。我们可以非常简单的给一个异步任务加上重试策略。</p>
<p><pre class="listing">
<span class="Keyword">int</span> <span class="Identifier">retryCountMax</span> <span class="Operator">=</span> <span class="DecNumber">3</span><span class="Punctuation">;</span>
<span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">retry</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">Task</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Punctuation">,</span> <span class="Identifier">Object</span><span class="Operator">&gt;</span><span class="Punctuation">)</span> <span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
      <span class="Comment">// 此任务最多会执行 retryCountMax 次，如成功则不再重试</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">retryCountMax</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
      <span class="Comment">// 成功，对数据进行消费</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
   <span class="Comment">// 进入此分支，说明3次重试均失败</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span></pre></p>
<p>我们可以指定<strong>重试策略</strong>，比如没有网络就不要重试了，或以每次以不同的时间间隔重试，避免造成服务器压力。</p>
<p><pre class="listing">
<span class="Keyword">int</span> <span class="Identifier">retryCountMax</span> <span class="Operator">=</span> <span class="DecNumber">3</span><span class="Punctuation">;</span>
<span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">retry</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">Task</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Punctuation">,</span> <span class="Identifier">Object</span><span class="Operator">&gt;</span><span class="Punctuation">)</span> <span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
      <span class="Comment">// 此任务最多会执行 retryCountMax 次，如成功则不再重试</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">retryCountMax</span><span class="Punctuation">,</span> <span class="Keyword">new</span> <span class="Identifier">RetryStrategy</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
    <span class="Operator">@</span><span class="Identifier">Override</span>
    <span class="Keyword">public</span> <span class="Identifier">Timeout</span> <span class="Identifier">delay</span><span class="Punctuation">(</span><span class="Keyword">int</span> <span class="Identifier">retrySeq</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
              <span class="Comment">// 指定每次重试的间隔</span>
              <span class="Comment">// 此处实现间隔1s,2s,3s...重试的效果</span>
        <span class="Keyword">return</span> <span class="Identifier">Timeout</span><span class="Punctuation">.</span><span class="Identifier">ofSeconds</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Keyword">long</span><span class="Punctuation">)</span> <span class="Identifier">retrySeq</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
    <span class="Punctuation">}</span>
    
    <span class="Operator">@</span><span class="Identifier">Override</span>
    <span class="Keyword">public</span> <span class="Keyword">boolean</span> <span class="Identifier">condition</span><span class="Punctuation">(</span><span class="Keyword">int</span> <span class="Identifier">attemptsRemain</span><span class="Punctuation">,</span> <span class="Identifier">Throwable</span> <span class="Identifier">throwable</span><span class="Punctuation">,</span> <span class="Identifier">Object</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
           <span class="Comment">// 该方法返回true，则继续重试，返回false中止重试。</span>
           <span class="Comment">// 入参包含当前重试的次数，以及上一次重试的错误原因。</span>
        <span class="Keyword">return</span> <span class="Keyword">true</span><span class="Punctuation">;</span>
    <span class="Punctuation">}</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
      <span class="Comment">// 成功，对数据进行消费</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
   <span class="Comment">// 进入此分支，说明3次重试均失败</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span></pre></p>
<p>组件内部内置两种常用的重试策略，如果不指定重试策略参数，则使用默认<strong>Default</strong>重试策略，具体为<tt class="docutils literal"><span class="pre"><span class="Identifier">固定间隔1秒重试直到最大重试次数</span></span></tt>。</p>
<p><pre class="listing">
<span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">retry</span><span class="Punctuation">(</span><span class="Punctuation">.</span><span class="Punctuation">.</span><span class="Punctuation">.</span><span class="Punctuation">,</span> <span class="Identifier">retryMaxCount</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Comment">// 相当于</span>
<span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">retry</span><span class="Punctuation">(</span><span class="Punctuation">.</span><span class="Punctuation">.</span><span class="Punctuation">.</span><span class="Punctuation">,</span> <span class="Identifier">retryMaxCount</span><span class="Punctuation">,</span><span class="Identifier">RetryStrategy</span><span class="Punctuation">.</span><span class="Identifier">Default</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>
<p>内置的两种重试策略具体实现如下，也可以扩展此接口以实现更适合业务的自定义策略。</p>
<p><pre class="listing">
<span class="Keyword">public</span> <span class="Keyword">interface</span> <span class="Identifier">RetryStrategy</span> <span class="Punctuation">{</span>
    <span class="Keyword">default</span> <span class="Identifier">Timeout</span> <span class="Identifier">delay</span><span class="Punctuation">(</span><span class="Keyword">int</span> <span class="Identifier">retrySeq</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
        <span class="Keyword">return</span> <span class="Identifier">Timeout</span><span class="Punctuation">.</span><span class="Identifier">ofSeconds</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
    <span class="Punctuation">}</span>
    <span class="Keyword">default</span> <span class="Keyword">boolean</span> <span class="Identifier">condition</span><span class="Punctuation">(</span><span class="Keyword">int</span> <span class="Identifier">attemptsRemain</span><span class="Punctuation">,</span> <span class="Identifier">Throwable</span> <span class="Identifier">throwable</span><span class="Punctuation">,</span> <span class="Identifier">Object</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
        <span class="Keyword">return</span> <span class="Keyword">true</span><span class="Punctuation">;</span>
    <span class="Punctuation">}</span>
    
    <span class="Identifier">RetryStrategy</span> <span class="Identifier">Default</span> <span class="Operator">=</span> <span class="Keyword">new</span> <span class="Identifier">RetryStrategy</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Punctuation">}</span><span class="Punctuation">;</span>
    <span class="Identifier">RetryStrategy</span> <span class="Identifier">Common</span> <span class="Operator">=</span> <span class="Keyword">new</span> <span class="Identifier">RetryStrategy</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
        <span class="Operator">@</span><span class="Identifier">Override</span>
        <span class="Keyword">public</span> <span class="Identifier">Timeout</span> <span class="Identifier">delay</span><span class="Punctuation">(</span><span class="Keyword">int</span> <span class="Identifier">retrySeq</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
            <span class="Keyword">return</span> <span class="Identifier">Timeout</span><span class="Punctuation">.</span><span class="Identifier">ofSeconds</span><span class="Punctuation">(</span><span class="DecNumber">2L</span><span class="Operator">*</span> <span class="Identifier">retrySeq</span><span class="Punctuation">)</span><span class="Punctuation">;</span><span class="Comment">//2,4,6,8 etc...</span>
        <span class="Punctuation">}</span>
    <span class="Punctuation">}</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span></pre></p>
<p>同样的，该方法返回一个新的Promise对象。</p>
<blockquote class="markdown-quote"><p>注意，使用此接口须将重试次数控制在合理范围内，一般3至5次重试就能满足大多数需求。此接口不适用于长时间重试或无限重试的场景，建议使用<tt class="docutils literal"><span class="pre"><span class="Identifier">TimerTask</span></span></tt>对Promise进行进一步封装，请参考如下例子。</p></blockquote>
<p><pre class="listing">
<span class="LongComment">/**
 * 固定的间隔重试某个任务，直到主动取消或超时为止，timeout设为null，代表该任务永不超时
 * @param task 需要执行的任务
 * @param periodMills 重试间隔时间，单位为毫秒
 * @param timeout 超时时间，可以为null，代表该任务永不超时
 **/</span>
<span class="Keyword">public</span> <span class="Keyword">static</span> <span class="Operator">&lt;</span><span class="Identifier">T</span><span class="Operator">&gt;</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">T</span><span class="Operator">&gt;</span> <span class="Identifier">fixRateRepeat</span><span class="Punctuation">(</span><span class="Identifier">Supplier</span><span class="Operator">&lt;</span><span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">T</span><span class="Operator">&gt;&gt;</span> <span class="Identifier">task</span><span class="Punctuation">,</span> <span class="Keyword">long</span> <span class="Identifier">periodMills</span><span class="Punctuation">,</span>  <span class="Identifier">Timeout</span> <span class="Identifier">timeout</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
    <span class="Identifier">Timer</span> <span class="Identifier">t</span> <span class="Operator">=</span> <span class="Keyword">new</span> <span class="Identifier">Timer</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
    <span class="Identifier">TimerTask</span> <span class="Identifier">tt</span> <span class="Operator">=</span> <span class="Keyword">new</span> <span class="Identifier">TimerTask</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
        <span class="Operator">@</span><span class="Identifier">Override</span>
        <span class="Keyword">public</span> <span class="Keyword">void</span> <span class="Identifier">run</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
            <span class="Identifier">task</span><span class="Punctuation">.</span><span class="Identifier">get</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
        <span class="Punctuation">}</span>
    <span class="Punctuation">}</span><span class="Punctuation">;</span>
    <span class="Identifier">Deferred</span><span class="Operator">&lt;</span><span class="Identifier">T</span><span class="Operator">&gt;</span> <span class="Identifier">deferred</span> <span class="Operator">=</span> <span class="Keyword">new</span> <span class="Identifier">Deferred</span><span class="Operator">&lt;</span><span class="Identifier">T</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Identifier">timeout</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
    <span class="Keyword">if</span> <span class="Punctuation">(</span><span class="Identifier">timeout</span> <span class="Operator">!=</span> <span class="Keyword">null</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Comment">// timeout从offer方法调度后开始计算</span>
        <span class="Identifier">deferred</span><span class="Punctuation">.</span><span class="Identifier">offer</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
    <span class="Punctuation">}</span>
    <span class="Identifier">deferred</span><span class="Punctuation">.</span><span class="Identifier">done</span><span class="Punctuation">(</span><span class="Identifier">o</span> <span class="Operator">-&gt;</span> <span class="Identifier">tt</span><span class="Punctuation">.</span><span class="Identifier">cancel</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
    <span class="Identifier">t</span><span class="Punctuation">.</span><span class="Identifier">scheduleAtFixedRate</span><span class="Punctuation">(</span><span class="Identifier">tt</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">periodMills</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
    <span class="Keyword">return</span> <span class="Identifier">deferred</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="实用接口-validation" href="#实用接口-validation">validation</a></h2><p><span id="validation_1">validation</span> 对数据进行进一步校验，返回代表校验结果的新Promise对象。</p>
<p><pre class="listing">
<span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">resolve</span><span class="Punctuation">(</span><span class="StringLit">&quot;something&quot;</span><span class="Punctuation">)</span>
        <span class="Punctuation">.</span><span class="Identifier">validate</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Identifier">s</span><span class="Punctuation">.</span><span class="Identifier">length</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">9</span><span class="Punctuation">)</span>
        <span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
             <span class="Comment">// 结果是合法的</span>
         <span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
             <span class="Comment">// 如校验失败 error 类型为 ValidationFailedException</span>
         <span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>
<p>我们可以把常用的数据校验规则收归并存储起来，随时使用，结合Promise实现更为强大效果</p>
<p><pre class="listing">
<span class="Comment">// 以下规则校验输入的字符串不能为空，且长度必须大于5</span>
<span class="Identifier">Validation</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span> <span class="Identifier">ensureStrLengthIsFive</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">Validation</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">)</span> <span class="Identifier">o</span> <span class="Operator">-&gt;</span> <span class="Identifier">o</span> <span class="Operator">!=</span> <span class="Keyword">null</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="DecNumber">1001</span><span class="Punctuation">,</span> <span class="StringLit">&quot;string is null&quot;</span><span class="Punctuation">)</span>
        <span class="Punctuation">.</span><span class="Identifier">andThen</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">Validation</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">)</span> <span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Identifier">s</span><span class="Punctuation">.</span><span class="Identifier">length</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">&gt;</span> <span class="DecNumber">5</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="DecNumber">1002</span><span class="Punctuation">,</span><span class="StringLit">&quot;string length not corrent&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">;</span>

<span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">resolve</span><span class="Punctuation">(</span><span class="StringLit">&quot;hi&quot;</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">validate</span><span class="Punctuation">(</span><span class="Identifier">ensureStrLengthIsFive</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Keyword">if</span> <span class="Punctuation">(</span><span class="Identifier">error</span> <span class="Keyword">instanceof</span> <span class="Identifier">ValidationFailedException</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
        <span class="Keyword">long</span> <span class="Identifier">errCode</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">ValidationFailedException</span><span class="Punctuation">)</span> <span class="Identifier">error</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">getErrorCode</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span> <span class="Comment">// 错误码 1002</span>
        <span class="Identifier">String</span> <span class="Identifier">errMsg</span> <span class="Operator">=</span> <span class="Identifier">error</span><span class="Punctuation">.</span><span class="Identifier">getMessage</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span> <span class="Comment">// 对应的错误提示</span>
    <span class="Punctuation">}</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span>

<span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">resolve</span><span class="Punctuation">(</span><span class="StringLit">&quot;something&quot;</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">validate</span><span class="Punctuation">(</span><span class="Identifier">ensureStrLengthIsFive</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">then</span><span class="Punctuation">(</span><span class="Identifier">s</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// ok 满足要求，校验通过</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span></pre></p>

<h1><a class="toc-backref" id="流程控制" href="#流程控制">流程控制</a></h1>
<h2><a class="toc-backref" id="流程控制-join" href="#流程控制-join">join</a></h2><p><span id="join_1">join</span> 把异步操作转换为同步。在某些场景，我们可能需要同步获取一个任务的执行执行结果。 在异步执行失败的情况下，该方法会抛出一个<tt class="docutils literal"><span class="pre"><span class="Identifier">PromiseException</span></span></tt>，有以下可能的情况。</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">PromiseCompleteException</span></span></tt></li>
</ul>
<p>异步任务执行失败，即异步任务调用了<strong>reject.apply</strong>方法。</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">PromiseTimeoutException</span></span></tt></li>
</ul>
<p>异步任务执行超时，<strong>每个promise都可以指定一个超时时间</strong>，没有在规定的时间内完成状态扭转，则抛出此异常。</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">PromiseException</span></span></tt></li>
</ul>
<p>异步任务执行过程中发生的其它异常，如NP等。<strong>Promise在执行过程中发生的异常都会被捕捉</strong>，确保不会引起程序崩溃。</p>
<p><pre class="listing">
<span class="Identifier">String</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">String</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// 异步任务</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">join</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Comment">//如果没有发生异常，在这里对s进行处理</span></pre></p>

<h2><a class="toc-backref" id="流程控制-abort" href="#流程控制-abort">abort</a></h2><p><span id="abort_1">abort</span> 放弃任务，其执行结果取决于当前Promise的状态。对于已经处于 <strong>Done</strong> 状态的Promise，无任何效果，否则立即扭转为Reject态。</p>
<p>传统的Promise并没有支持取消的接口，TC39官方<a class="reference external" href="https://github.com/tc39/proposal-cancelable-promises">曾经有个提案</a> 但已经被否决 。 目前官方提供的解决方案是使用<a class="reference external" href=" https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort">AbortController</a> 与Promise配合实现取消功能。实际使用过程中对单个Promised对象尚可接受，但在链式调用中，我们很难知道异步任务执行到了什么阶段，应该取消那个Promise对象，甚至取不到Promise对象的引用。</p>
<p>除此之外，也有使用<tt class="docutils literal"><span class="pre"><span class="Identifier">Promise</span><span class="Operator">.</span><span class="Identifier">race</span></span></tt>接口包装的一个可取消的promise对象的方案，比如 <a class="reference external" href="https://stackoverflow.com/questions/30233302/promise-is-it-possible-to-force-cancel-a-promise">SF上的一个讨论</a>。笔者认为此方案使用起来相对繁琐，代码可读性也不高。</p>
<p>在我们的实现中，取消一个Promise非常简单，只需要调用Promise对象的abort 方法即可，一次调用，可以轻松取消掉整个Promise链，顺便实现了 <a class="reference external" href="https://en.wikipedia.org/wiki/Structured_concurrency">结构化并发</a>的效果。</p>
<p><pre class="listing">
<span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">Void</span><span class="Operator">&gt;</span> <span class="Identifier">promise</span> <span class="Operator">=</span> <span class="Identifier">Promise</span><span class="Punctuation">.</span><span class="Identifier">delay</span><span class="Punctuation">(</span><span class="Identifier">Timeout</span><span class="Punctuation">.</span><span class="Identifier">ofMillis</span><span class="Punctuation">(</span><span class="DecNumber">2000</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Keyword">null</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Identifier">promise</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// error类型为 AbortException</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">done</span><span class="Punctuation">(</span><span class="Identifier">o</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// o类型为PromiseException，getCause返回对象类型为 AbortException</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Identifier">promise</span><span class="Punctuation">.</span><span class="Identifier">abort</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span> <span class="Comment">// 任务取消</span></pre></p>
<p>在abort接口被调用后，abort事件会在整个异步任务链上传播，取消掉整个任务链。比如上述代码中，Promise被取消后，2000ms的定时器资源如果没有申请，那么不再申请，如果已经申请了，该定时器资源会被自动释放。</p>
<p>开发者也可以通过覆写<tt class="docutils literal"><span class="pre"><span class="Identifier">onAbort</span></span></tt>方法，实现资源释放的善后工作，如下代码示例演示与OKHttp的结合。</p>
<p><pre class="listing">
<span class="Identifier">AbortController</span> <span class="Identifier">controller</span> <span class="Operator">=</span> <span class="Keyword">new</span> <span class="Identifier">AbortController</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">Integer</span><span class="Operator">&gt;</span> <span class="Identifier">promise</span> <span class="Operator">=</span> <span class="Keyword">new</span> <span class="Identifier">Promise</span><span class="Operator">&lt;</span><span class="Identifier">Integer</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">resolve</span><span class="Punctuation">,</span> <span class="Identifier">reject</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
      <span class="Comment">// 注册清理资源的操作</span>
      <span class="Identifier">controller</span><span class="Punctuation">.</span><span class="Identifier">signal</span><span class="Punctuation">.</span><span class="Identifier">onAbort</span><span class="Punctuation">(</span><span class="Identifier">reason</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
              <span class="Comment">// 这里需要考虑多线程资源竞争，因为发送HTTP请求与取消HTTP请求可能不在同一个线程</span>
              <span class="Identifier">OkHttpUtils</span><span class="Punctuation">.</span><span class="Identifier">cancelCall</span><span class="Punctuation">(</span><span class="Identifier">client</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
    <span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
      <span class="Comment">// 发送HTTP请求（同步方法，耗时操作）</span>
      <span class="Identifier">Response</span> <span class="Identifier">response</span> <span class="Operator">=</span> <span class="Identifier">client</span><span class="Punctuation">.</span><span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="Identifier">request</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">execute</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
      <span class="Comment">// 使用资源</span>
      <span class="Identifier">resolve</span><span class="Punctuation">.</span><span class="Identifier">apply</span><span class="Punctuation">(</span><span class="Identifier">response</span><span class="Punctuation">.</span><span class="Identifier">code</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
    <span class="Operator">@</span><span class="Identifier">Override</span>
    <span class="Keyword">public</span> <span class="Keyword">void</span> <span class="Identifier">onAbort</span><span class="Punctuation">(</span><span class="Identifier">String</span> <span class="Identifier">reason</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
        <span class="Identifier">controller</span><span class="Punctuation">.</span><span class="Identifier">abort</span><span class="Punctuation">(</span><span class="Identifier">reason</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
    <span class="Punctuation">}</span>
<span class="Punctuation">}</span><span class="Punctuation">.</span><span class="Identifier">except</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">error</span><span class="Punctuation">,</span> <span class="Identifier">o</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// error类型为 AbortException</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">.</span><span class="Identifier">done</span><span class="Punctuation">(</span><span class="Identifier">o</span> <span class="Operator">-&gt;</span> <span class="Punctuation">{</span>
    <span class="Comment">// o类型为PromiseException，getCause返回对象类型为 AbortException</span>
<span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">;</span>

<span class="Identifier">promise</span><span class="Punctuation">.</span><span class="Identifier">abort</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span><span class="Comment">// 任务取消</span></pre></p>
<p>在Kotlin里使用的例子。</p>
<p><pre class="listing">
// 创建一个 AbortController 对象
val abortController = AbortController()

// 创建一个Promise对象，并执行
val promise = object : Promise&lt;String&gt;(Task&lt;String, Any&gt; { resolve, _ -&gt;
    val t1 = Thread.currentThread()
    abortController.signal.onAbort {
        t1.interrupt()
    }
      // 模拟耗时操作
    try {
        Thread.sleep(2000)
    } catch (e: InterruptedException) {
        Log.d(TAG, &quot;InterruptedException: $e&quot;)
    }
    resolve.apply(&quot;SUCCESS&quot;)
}, Timeout.ofMillis(3000)) {
    override fun onAbort(reason: String?) {
        abortController.abort(reason)
    }
}.then {
    Log.d(TAG, &quot;then&quot;)
}.except { throwable: Throwable?, any: Any? -&gt;
    Log.d(TAG, &quot;except $throwable $any&quot;)
}.done {
    Log.d(TAG, &quot;done&quot;)
}

// 在需要时中止 Promise 的执行
promise.abort()</pre></p>

<h1><a class="toc-backref" id="并发控制" href="#并发控制">并发控制</a></h1>
<h2><a class="toc-backref" id="并发控制-all" href="#并发控制-all">all</a></h2><p><span id="all_1">all</span> 接受任意个Promise对象，并发执行异步任务。全部任务成功，有一个失败则视为整体失败。</p>

<h2><a class="toc-backref" id="并发控制-race" href="#并发控制-race">race</a></h2><p><span id="race_1">race</span> 接受任意个Promise对象，并发执行异步任务。时间是第一优先级，多个任务以最先返回的那个结果为准，此结果成功即为整体成功，失败则为整体失败。</p>

<h2><a class="toc-backref" id="并发控制-any" href="#并发控制-any">any</a></h2><p><span id="any_1">any</span> 接受任意个Promise对象，并发执行异步任务。等待其中一个成功即为成功，全部任务失败则进入错误状态，输出错误列表。</p>

<h2><a class="toc-backref" id="并发控制-allsettled" href="#并发控制-allsettled">allSettled</a></h2><p><span id="allsettled_1">allSettled</span> 任务优先，所有任务必须执行完毕，永远不会进入失败状态。</p>
<p>详情可参阅 <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN Promise API文档</a> ，具体实现是一致的。</p>

<h1><a class="toc-backref" id="内存安全" href="#内存安全">内存安全</a></h1><p>异步任务和多线程并发是业务处理过程中的一大难题，稍有不慎便会出现崩溃，死锁，变量同步等问题。使用Promise技术可以安全高效的解决上述两大难题。</p>
<p>首先，Promise解决了异步数据流管理问题，另外Promise每个异步任务是天然多线程执行的。在可以并发的情况下，会并发执行以最大化提升程序的运行效率，例如<tt class="docutils literal"><span class="pre"><span class="Identifier">all</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">race</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">any</span></span></tt>等接口，这些接口抽象了常用的并发模型。</p>
<p>这里如果展开来讲的话，篇幅会比较长，这里只是做个简略的说明，使用Promise模式进行异步编程，开发者一般不需要关心此类问题。</p>

<h1><a class="toc-backref" id="其他说明" href="#其他说明">其他说明</a></h1>
<h2><a class="toc-backref" id="其他说明-使用要求" href="#其他说明-使用要求">使用要求</a></h2><p>不依赖任何第三方库，具体要求如下</p>
<ul class="simple"><li>Java平台: Java版本&gt;=1.8</li>
<li>安卓平台: Android版本&gt;=24 (Nougat)</li>
</ul>
<p>安卓平台可以通过<a class="reference external" href="https://github.com/retrostreams/android-retrofuture">android-retrofuture</a> 支持更旧的安卓版本（尚未实现）。</p>

<h2><a class="toc-backref" id="其他说明-资源" href="#其他说明-资源">资源</a></h2><ul class="simple"><li>Future/Promise 有细微的不同，具体见(<a class="reference external" href="https://en.wikipedia.org/wiki/Futures_and_promises">https://en.wikipedia.org/wiki/Futures_and_promises</a>)</li>
<li>Google实现了Swift版本的Promise库(<a class="reference external" href="https://github.com/google/promises">https://github.com/google/promises</a>)</li>
<li><a class="reference external" href="https://github.com/ReactiveX/RxJava">RxJava</a> 一种响应式编程，基于异步数据流概念的编程模式。</li>
<li>Promise规范 <a class="reference external" href="https://promisesaplus.com/">Promise A+</a>。</li>
<li><a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN Promise API文档</a>。</li>
<li><a class="reference external" href="https://promisesaplus.com/">Promise A+规范</a></li>
</ul>
</p>
    
  </div>
</div>

      <div class="twelve-columns footer"><small style="color: var(--hint);">Copyright © 2024 pro4j.com.</small></div>
    </div>
  </div>
  
  <!-- Google fonts -->
  <link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
  <link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-39TC9XREHY"></script>
  <script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-39TC9XREHY');</script>
  </body>
</html>
